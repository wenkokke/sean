


----------------------------------------
-- stl :  --
----------------------------------------

attr Lexicon Decls Decl Tm
  syn stl :: self
  syn subd :: self
  
attr Tm
  syn hm :: MbTy
  syn subs use {`mappend`} {mempty} :: TySubst
  inh subs :: TySubst
  
{
class    HasHm tm      where hm :: tm -> Tm
instance HasHm Tm      where hm tm = stl_Syn_Tm $ wrap (sem tm) ((inh tm) {env_Inh_Tm=tyEnv tm})
instance HasHm Decl    where hm dc = stl_Syn_Decl $ wrap (sem dc) ((inh dc) {env_Inh_Decl=tyEnv dc})
instance HasHm Lexicon where hm lx = stl_Syn_Lexicon $ wrap (sem lx) ((inh lx) {env_Inh_Lexicon=tyEnv lx})
}

sem Decl
  | TyDecl lhs.stl = TyDecl @an.it @ident.it
  | TmDecl lhs.stl = TmDecl @an.it @name @tm.stl

sem Tm
  | Var -- type of var
        inst.varTy :: MbTy
        inst.varTy = @ident.ty <|> @lhs.tyDecl <|> Map.lookup @ident.name @lhs.env
        varTy.fsh  = @lhs.fsh
        varTy.ftv  = tyPrim
        
        inst.hmTy  :: Ty
        inst.hmTy  = @varTy.orFresh
        hmTy.fsh   = @varTy.fsh
        hmTy.ftv   = tyPrim
        
        loc.hm     = return @hmTy.ins
        lhs.stl    = Var @ident.it @hm
        lhs.fsh    = @hmTy.fsh

  | Lam -- type declarations
        tm .tyDecl = Nothing
  
        -- type of lambda
        inst.argTy :: MbTy
        inst.argTy = @ident.ty
        argTy.ftv  = tyPrim
        
        inst.hmTy  :: Ty
        inst.hmTy  = @argTy.orFresh
        
        loc .hm    = TyApp @hmTy.it <$> @tm.stl
        lhs .stl   = Lam (Ident @ident.name (Just @hmTy.it)) @tm.stl
        
        -- flow lhs => tm => lhs
        tm   .env  = Map.insert @ident.name @argTy.orFresh @lhs.env
        lhs  .env  = Map.delete @ident.name @tm.env
        
        -- flow lhs => argTy => tm => lhs
        argTy.fsh  = @lhs.fsh
        tm   .fsh  = @argTy.fsh
        lhs  .fsh  = @tm.fsh
        
  | App -- type declarations
        tm1.tyDecl = Nothing
        tm2.tyDecl = Nothing
  
        -- type of return value
        loc.retTy  = TyVar $ head @lhs.fsh
        -- type of function
        loc.funTy  = do ty1 <- @tm1.hm 
                        ty2 <- @tm2.hm
                        return $ unify tyPrim ty1 (ty2 ~> @retTy)
        lhs.hm     = (return . (flip subst) @retTy) <$> @funTy
        lhs.stl    = App @tm1.stl @tm2.stl
        
        -- substitution
        lhs.subs   = fold @funTy `mappend` (@tm2.subs `mappend` @tm1.subs)
                        
        -- flow lhs => tm1 => tm2 => lhs
        tm1.fsh    = tail @lhs.fsh
        tm2.fsh    = @tm1.fsh
        lhs.fsh    = @tm2.fsh
        
        -- flow lhs => tm1 => tm2 => lhs
        tm1.env    = @lhs.env
        tm2.env    = @tm1.env
        lhs.env    = case @funTy of
                        Just sb -> subst sb @tm2.env
                        Nothing -> error "shouldn't happen"




