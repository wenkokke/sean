
imports
{
import Data.Maybe (fromJust)
import UU.Pretty (PP,PP_Doc,(>-<),(>|<),(>#<),text,pp,pp_parens)
import qualified UU.Pretty as PP (empty)
}

attr AnS TyS TmS Ident
  syn pp use {>-<} {PP.empty} :: PP_Doc
  
sem Decl
  | TyDecl loc.pp = PP.empty
  | TmDecl loc.pp = @an.pp >-< text @name >#< text ":" >#< @hm.pp >#< text "=" >#< @tm.pp
  
sem An
  | Publ  loc.pp = text "public"
  | Priv  loc.pp = text "private"
  
attr Ty Tm
  syn pp_parens :: PP_Doc
  
sem Ty
  | TyVar loc.pp        = text @ident
          loc.pp_parens = @pp
  | TyApp loc.pp        = @ty1.pp_parens >|< @ty2.pp
          loc.pp_parens = pp_parens @pp
  | TyAll loc.pp        = text "!" >|< text @ident >|< text "." >|< @ty.pp
          loc.pp_parens = pp_parens @pp
        
sem Tm
  | Var loc.pp        = text @ident.name >|< text ":" >|< @hm.pp
        loc.pp_parens = @pp
  | App loc.pp        = @tm1.pp_parens >#< @tm2.pp_parens
        loc.pp_parens = pp_parens @pp
  | Lam loc.pp        = text "\\" >|< text @ident.name >|< text ":" >|< @hm.pp >|< text "." >|< @tm.pp
        loc.pp_parens = pp_parens @pp
        
sem Ident
  | Ident loc.pp      = text @name >|< text ":" >|< @ty.pp

-- show
{
instance PP   Ty      where pp = pp_Syn_Ty . syn
instance PP   An      where pp = pp_Syn_An . syn
instance PP   Tm      where pp tm = pp_Syn_Tm $ wrap (sem tm) ((inh tm) {env_Inh_Tm=tyEnv tm})
instance PP   Decl    where pp st = pp_Syn_Decl $ wrap (sem st) ((inh st) {env_Inh_Decl=tyEnv st})
instance PP   Lexicon where pp lx = pp_Syn_Lexicon $ wrap (sem lx) ((inh lx) {env_Inh_Lexicon=tyEnv lx})
instance Show Ty      where show = show . pp
instance Show An      where show = show . pp
instance Show Tm      where show = show . pp
instance Show Decl    where show = show . pp
instance Show Lexicon where show = show . pp
}
