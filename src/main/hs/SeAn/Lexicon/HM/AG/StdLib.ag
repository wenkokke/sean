
imports
{
import Prelude hiding (and,or,not)
import Control.Monad (join)
import Data.IntMap (IntMap,(!),insert,empty,fold)
}

{
-- |Default type environment.
env :: TyEnv
env = Map.fromList . map unpack $
  [ forall  , exists
  , iota    , eq
  , implies , and
  , or      , not    ]
  where
  unpack :: Tm -> (Var,Ty)
  unpack (Var (Ident name (Just ty))) = (name,ty)

-- |List of primitive semantic type variables.
tyPrim :: [TyVar]
tyPrim = ["e","t"]

-- |Semantic type combination.
(~>) :: Ty -> Ty -> Ty
(~>) = TyApp

-- |Basic semantic types.
e,t :: Ty
e = TyVar "e"
t = TyVar "t"

-- |Linear semantic types.
et    = e ~> t
eet   = e ~> et
eeet  = e ~> eet
ee    = e ~> e
tt    = t ~> t
ttt   = t ~> tt
et_t  = et ~> t
et_e  = et ~> e
et_et = et ~> et

-- |Complex semantic types.
levels :: IntMap [Ty]
levels = foldl level empty [0..5]

level :: IntMap [Ty] -> Int -> IntMap [Ty]
level m 0 = insert 0 [e,t] m
level m n = insert n [a ~> b | a <- d, b <- d] m where d = fold (++) [] m

-- |Function definition function.
define :: Var -> Ty -> Tm
define x ty = Var (Ident x $ Just ty)

-- |Encoding of universal quantifier in lambda calculus.
forall  :: Tm
forall   = define "FORALL" et_t

-- |Encoding of existential quantifier in lambda calculus.
exists  :: Tm 
exists   = define "EXISTS" et_t

-- |Encoding of iota function in lambda calculus.
iota    :: Tm
iota     = define "IOTA" et_e

-- |Encoding of material implication in lambda calculus.
implies :: Tm 
implies  = define "IMPLIES" ttt

-- |Encoding of equality relation in lambda calculus.
eq      :: Tm 
eq       = define "EQ" eet

-- |Encoding of conjunction in lambda calculus.
and     :: Tm 
and      = define "AND" ttt

-- |Encoding of disjunction in lambda calculus.
or      :: Tm 
or       = define "OR" ttt

-- |Encoding of negation in lambda calculus.
not     :: Tm
not      = define "NOT" tt
}
