
imports
{
import Debug.Trace (traceShow)
import Control.Applicative ((<$>),(<|>))
}


-- * Hinley-Milner Type Inference

attr Lexicon Decls Decl AnS Tm TyS Ident
  syn stl :: self
  
attr Tm
  syn stlTy :: MbTy
  syn subs :: TySubst
  
sem Tm
  | Var inst.varTy :: MbTy
        inst.varTy  = @ty <|> @lhs.decl <|> Map.lookup @name @lhs.env
        varTy.fresh = @lhs.fresh
        varTy.ftv   = tyPrim
        
        inst.fshTy  :: Ty
        inst.fshTy  = @varTy.orFresh
        fshTy.fresh = @varTy.fresh
        fshTy.ftv   = tyPrim
        
        loc.stlTy   = return @fshTy.ins
        lhs.stl     = Var (Ident @name @stlTy)
        lhs.fresh   = @fshTy.fresh
        
  | Lam inst.argTy  :: MbTy
        inst.argTy  = @ty
        argTy.fresh = @lhs.fresh
        argTy.ftv   = tyPrim
        
        inst.fshTy  :: Ty
        inst.fshTy  = @argTy.orFresh
        fshTy.fresh = @argTy.fresh
        fshTy.ftv   = tyPrim
        
        loc .stlTy  = TyApp @fshTy.it <$> @tm.stlTy
        lhs .stl    = Lam (Ident @name (Just @fshTy.it)) @tm.stl
        
        tm   .env   = Map.insert @name @fshTy.it @lhs.env
        lhs  .env   = Map.delete @name @tm.env
        tm   .fresh = @fshTy.fresh
        lhs  .fresh = @tm.fresh
        
  | App loc.retTy  = TyVar $ head @lhs.fresh
        loc.tySub  = do ty1 <- @tm1.stlTy 
                        ty2 <- @tm2.stlTy
                        let s = unify tyPrim ty1 (ty2 ~> @retTy)
                        return $ traceShow s s
        lhs.stlTy  = do tySub <- @tySub ; return $ subst tySub @retTy
        
        inst.stl   :: Tm
        inst.stl   = App @tm1.stl @tm2.stl
        --stl .subs  = @subs
        lhs .stl   = @stl.it
        
        -- substitution
        --loc .subs  = fold @tySub `mappend` (@tm2.subs `mappend` @tm1.subs)
                        
        -- flow lhs => tm1 => tm2 => lhs
        tm1.fresh  = tail @lhs.fresh
        tm2.fresh  = @tm1.fresh
        lhs.fresh  = @tm2.fresh
        
        -- flow lhs => tm1 => tm2 => lhs
        tm1.env    = @lhs.env
        tm2.env    = @tm1.env
        lhs.env    = case @tySub of
                     Just sb -> subst sb @tm2.env
                     Nothing -> error "shouldn't happen"

-- |Convert optional types either to fresh type variables
--  or to the type they represent.
attr MbTy
  syn orFresh :: Ty

sem MbTy
   | Just    lhs.orFresh = @just.it
   | Nothing lhs.orFresh = TyVar $ head @lhs.fresh
             lhs.fresh   = tail @lhs.fresh
             
{
class    HasHm tm      where stl :: tm -> tm
instance HasHm Tm      where stl tm = stl_Syn_Tm $ wrap (sem tm) ((inh tm) {env_Inh_Tm=tyEnv tm})
instance HasHm Decl    where stl dc = stl_Syn_Decl $ wrap (sem dc) ((inh dc) {env_Inh_Decl=tyEnv dc})
instance HasHm Lexicon where stl lx = stl_Syn_Lexicon $ wrap (sem lx) ((inh lx) {env_Inh_Lexicon=tyEnv lx})
}

-- * Type Unification

{
-- |Type unification as per Robinson's algorithm.
unify :: FTV -> Ty -> Ty -> TySubst

unify prim (TyVar a) (TyVar b)
  | a == b                  = I
  | all (`elem` prim) [a,b] = error (printf "cannot unify %s and %s" a b)
  | a `elem` prim           = S b (TyVar a)
  | otherwise               = S a (TyVar b)

unify prim (TyVar a) b
  | a `elem` prim  = error (printf "cannot unify %s and %s" a (show b))
  | a `elem` ftv b = error "infinite type"
  | otherwise      = S a b

unify prim a (TyVar b)
  | b `elem` prim  = error (printf "cannot unify %s and %s" (show a) b)
  | b `elem` ftv a = error "infinite type"
  | otherwise      = S b a

unify prim (TyApp a b) (TyApp c d)
  = let s1 = unify prim a c
        s2 = unify prim (subst s1 b) (subst s1 d)
    in  s2 `mappend` s1
}

-- * Type Declaractions

-- |Type declarations are put into the environment, and passed
--  back in through the inherited attributes.
attr Tm
  inh decl :: MbTy

sem Decl
  | TmDecl tm .decl = Map.lookup @name @lhs.env
  
sem Tm
  | Lam    tm .decl = do TyApp _ ty <- @lhs.decl ; return ty
  | App    tm1.decl = Nothing
           tm2.decl = Nothing


-- * Type Instantiation

attr TyS TyEnv
  syn ins :: self

sem Ty
   | TyAll loc.var   = head @ty.fresh
           lhs.fresh = tail @ty.fresh
           loc.ins   = rename @ident @var @ty.ins

{
class    HasIns ty    where ins :: ty -> ty
instance HasIns Ty    where ins = ins_Syn_Ty . syn
instance HasIns TyEnv where ins = ins_Syn_TyEnv . syn
}

-- * Type Generalization

attr TyS TyEnv
  syn gen :: self

sem Ty
   | * loc.gen = foldr TyAll @it (@ftv \\ @lhs.ftv)

{
class    HasGen ty    where gen :: ty -> ty
instance HasGen Ty    where gen = gen_Syn_Ty . syn
instance HasGen TyEnv where gen = gen_Syn_TyEnv . syn
}
