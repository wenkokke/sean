
-- * Type Substitution

{
-- |Represents type substitutions.
data TySubst
  = I                 -- ^ the identity substitution;
  | S TyVar   Ty      -- ^ substitutes the second argument for the first;
  | O TySubst TySubst -- ^ substitution composition. 
  deriving (Eq)
  
-- |Type substitutions form a monoid.
instance Monoid TySubst where
  mempty      = I
  mappend I s = s
  mappend s I = s
  mappend a b = a `O` b
}

attr Tm Ident TyS TyEnv
  inh subs :: TySubst
  syn subd :: self

sem Decl
  | TyDecl ident.subs = mempty
  | TmDecl tm   .subs = mempty

sem Ty
  | TyAll lhs.subd = case @lhs.subs of
                     I       -> @it
                     S x  ty -> if @ident==x
                                then case ty of
                                     TyVar y -> TyAll y @ty.subd
                                     _       -> error $ "cannot substitute bound variable "++x++" with "++show ty
                                else TyAll @ident @ty.subd
  | TyVar lhs.subd = case @lhs.subs of
                     I       -> @it
                     S x  ty -> if @ident==x then ty else @it
                     O s2 s1 -> subst s2 (subst s1 @it)
  
{
svars :: TySubst -> TyVars
svars (I    ) = [ ]
svars (S x y) = [x]
svars (O f g) = svars f `union` svars g
}

{
class HasSub ty where
  subst   :: TySubst -> ty -> ty
  replace :: TyVar -> Ty -> ty -> ty
  replace a b ty = subst (S a b) ty
  rename  :: TyVar -> TyVar -> ty -> ty
  rename  a b ty = replace a (TyVar b) ty
  
instance HasSub Tm where
  subst s tm = subd_Syn_Tm $ wrap (sem tm) ((inh tm) {subs_Inh_Tm=s})

instance HasSub Ty where
  subst s ty = subd_Syn_Ty $ wrap (sem ty) ((inh ty) {subs_Inh_Ty=s})

instance HasSub TyEnv where
  subst s ty = fmap (subst s) ty
}

-- show
{
instance Show TySubst where
  show (I    ) = "I"
  show (S a b) = printf "[%s -> %s]" a (show b)
  show (O a b) = show a ++ show b
}